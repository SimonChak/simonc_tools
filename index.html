<!DOCTYPE html>
<html>
<head>
    <title>é–‹IBæª¢æŸ¥å°å·¥å…·</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial; margin: 20px; background: #f0f8ff; }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 1600px; margin: 0 auto; }
        .section { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        textarea { width: 100%; height: 300px; padding: 10px; border: 2px solid #007bff; border-radius: 5px; font-family: monospace; }
        button { background: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 10px 5px; }
        button:hover { background: #0056b3; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 2px solid #ddd; padding: 10px; text-align: center; }
        th { background: #e9ecef; font-weight: bold; }
        .debug-info { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .result-table { background: #f8f9fa; }
        .pass { background: #d4edda; }
        .fail { background: #f8d7da; }
        .not-found { background: #fff3cd; }
        .method-mismatch { background: #ffeaa7; }
        .step-check { background: #e7f3ff; }
        .step-pass { background: #d1e7dd; }
        .step-fail { background: #f8d7da; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <h1>ğŸ” æ™®é€šIB Bonusæª¢æŸ¥å·¥å…·(ECNé™¤å¤–)</h1>
    
    <div class="container">
        <div class="section">
            <h2>ğŸ“‹ Portalæ•¸æ“šï¼ˆè²¼ä¸Šé€™è£¡ï¼‰ç”±Bonus...æ‹‰åˆ°åº•1â€“10 of 14</h2>
            <textarea id="tableA" placeholder="è«‹è²¼ä¸ŠPortalç¶²é çš„è¡¨æ ¼æ•¸æ“š...">çé‡‘






STD	å¤–åŒ¯	0	5	USD	
O
STD	æ¨™æº–	0	100	%	
D
STD	A50	0	0.05	USD	
O
STD	å¤©ç„¶æ°£	0	0.5	USD	
O
Rows per page:

20
1â€“14 of 14</textarea>
        </div>

        <div class="section">
            <h2>ğŸ“‹ RBOæ•¸æ“šï¼ˆè²¼ä¸Šé€™è£¡ï¼‰ç”±Details ( Active ) ...æ‹‰åˆ°åº•Override</h2>
            <textarea id="tableB" placeholder="è«‹è²¼ä¸ŠRBOç¶²é çš„è¡¨æ ¼æ•¸æ“š...">Details ( Active )
====================================================================================================================
 	Rebate Type	Selection	Min. Lot	Start Date	End Date	Unit	Amount	Method
 	Trade Comm	STD	0.00	2025/09/10	
%	100.00	Direct
 	Trade Volume	STD_FX	0.00	2025/09/10	
USD	5.00	Override
 	Trade Volume	STD_A50	0.00	2025/09/10	
USD	0.05	Override
 	Trade Volume	STD_GAS	0.00	2025/09/10	
USD	0.5	Override</textarea>
        </div>

        <div class="section" style="grid-column: 1 / -1;">
            <h2>ğŸ“Š è§£æèˆ‡æ ¸å°çµæœ</h2>
            <button onclick="parseAndCheck()">é–‹å§‹è§£æèˆ‡æ ¸å°</button>
            <button onclick="clearAll()">æ¸…ç©ºæ‰€æœ‰</button>
            
            <div id="stepCheckResult"></div>
            <div id="finalResult"></div>
            <div id="debugResult"></div>
        </div>
    </div>

    <script>
        // ç”¢å“åç¨±æ˜ å°„è¡¨
        const productMapping = {
            'Forex': ['FX'],
            'å¤–åŒ¯': ['FX'],
            'Gold': ['GOLD'],
            'é»ƒé‡‘': ['GOLD'],
            'Silver': ['SILVER'],
            'ç™½éŠ€': ['SILVER'],
            'Oil': ['OIL'],
            'åŸæ²¹': ['OIL'],
            'GASUSD': ['GAS'],
            'å¤©ç„¶æ°£': ['GAS'],
            'HK50': ['HK50'],
            'æ’ç”ŸæŒ‡æ•¸': ['HK50'],
            'NAS100': ['NAS100'],
            'ç´æ–¯é”å…‹100æŒ‡æ•¸': ['NAS100'],
            'SPX500': ['SPX500'],
            'æ¨™æ™®500æŒ‡æ•¸': ['SPX500'],
            'US30': ['US30'],
            'é“ç“Šæ–¯æŒ‡æ•¸': ['US30'],
            'A50': ['A50'],
            'ä¸­è¯A50æŒ‡æ•¸': ['A50'],
            'JPN225': ['JPN225'],
            'æ—¥ç¶“225æŒ‡æ•¸': ['JPN225'],
            'GER30': ['GER30'],
            'å¾·åœ‹DAXæŒ‡æ•¸': ['GER30'],
            'GAUCNH': ['GAUCNH'],
            'äººæ°‘å¹£é»ƒé‡‘': ['GAUCNH'],
            'AUS200': ['AUS200'],
            'æ¾³æ´²200æŒ‡æ•¸': ['AUS200']
        };

        // ç‰¹æ®Šç”¢å“é¡å‹æ˜ å°„ï¼ˆSTD/PRO å’Œ æ¨™æº–/å°ˆæ¥­ï¼‰
        const productTypeMapping = {
            'STD': ['STD', ''],
            'PRO': ['PRO', ''],
            'æ¨™æº–': ['STD', ''],
            'å°ˆæ¥­': ['PRO', '']
        };

        // ç‰¹æ®Šç”¢å“å¢é‡æª¢æŸ¥è¦å‰‡
        const stepRules = {
            'A50': 0.05,  // A50å¿…é ˆæ˜¯0.05çš„å€æ•¸
            'ä¸­è¯A50æŒ‡æ•¸': 0.05,
            'GASUSD': 0.5,  // GASUSDå¿…é ˆæ˜¯0.5çš„å€æ•¸
            'å¤©ç„¶æ°£': 0.5
        };

        // æª¢æŸ¥å¢é‡è¦å‰‡
        function checkStepRule(productName, value) {
            const step = stepRules[productName];
            if (!step) return null; // æ²’æœ‰è¦å‰‡ï¼Œè¿”å›null
            
            const remainder = (value * 100) % (step * 100); // é¿å…æµ®é»æ•¸èª¤å·®
            const isValid = Math.abs(remainder) < 0.0001 || Math.abs(remainder - step * 100) < 0.0001;
            
            return {
                productName: productName,
                value: value,
                step: step,
                valid: isValid,
                reason: isValid ? 
                    `âœ… ç¬¦åˆ${step}å¢é‡è¦å‰‡` : 
                    `âŒ ä¸ç¬¦åˆ${step}å¢é‡è¦å‰‡ï¼ˆå¿…é ˆæ˜¯${step}çš„å€æ•¸ï¼‰`
            };
        }

        // æª¢æŸ¥æ—¥æœŸæ˜¯å¦åœ¨æœ‰æ•ˆç¯„åœå…§
        function isDateValid(startDate, endDate) {
            const today = new Date();
            
            if (startDate && startDate.trim() !== '') {
                const start = new Date(startDate.replace(/\//g, '-'));
                if (start > today) return false;
            }
            
            if (endDate && endDate.trim() !== '') {
                const end = new Date(endDate.replace(/\//g, '-'));
                if (end < today) return false;
            }
            
            return true;
        }

        // æª¢æŸ¥æ–¹æ³•æ˜¯å¦ä¸€è‡´
        function isMethodMatch(methodA, methodB) {
            if (methodA === 'D' && methodB === 'Direct') return true;
            if (methodA === 'O' && methodB === 'Override') return true;
            return false;
        }

        // ç²å–æ˜ å°„å¾Œçš„ç”¢å“åç¨±
        function getMappedProduct(productType, productName) {
            console.log('Mapping product:', productType, productName);
            
            // ç‰¹æ®Šè™•ç†ï¼šç•¶ç”¢å“åç¨±æ˜¯"STD"ã€"PRO"ã€"æ¨™æº–"æˆ–"å°ˆæ¥­"æ™‚
            if (productName === 'STD' || productName === 'PRO' || productName === 'æ¨™æº–' || productName === 'å°ˆæ¥­') {
                const mappedTypes = productTypeMapping[productName] || [productName];
                console.log('Special product mapping:', mappedTypes);
                
                const results = [];
                mappedTypes.forEach(type => {
                    if (type === '') {
                        // ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºç›´æ¥ä½¿ç”¨ç”¢å“é¡å‹
                        results.push(productType);
                    } else {
                        results.push(type);
                    }
                });
                console.log('Special product results:', results);
                return results;
            }
            
            // æ™®é€šç”¢å“è™•ç†
            const mapped = productMapping[productName];
            if (Array.isArray(mapped)) {
                const results = mapped.map(item => productType + '_' + item);
                console.log('Normal product mapping results:', results);
                return results;
            }
            
            const result = [productType + '_' + (mapped || productName)];
            console.log('Fallback product mapping result:', result);
            return result;
        }

        // å°‡æ–¹æ³•ä»£ç¢¼è½‰æ›ç‚ºå¯è®€åç¨±
        function getMethodName(methodCode) {
            if (methodCode === 'O') return 'Override';
            if (methodCode === 'D') return 'Direct';
            return methodCode;
        }

        function parseAndCheck() {
            const tableA = document.getElementById('tableA').value;
            const tableB = document.getElementById('tableB').value;
            
            let stepHTML = '';
            let debugHTML = '';
            let resultHTML = '';
            
            // è§£æPortalç¶²é æ•¸æ“š
            const linesA = tableA.trim().split('\n');
            const dataA = [];
            let skipNext = false;
            
            for (let i = 0; i < linesA.length; i++) {
                if (skipNext) {
                    skipNext = false;
                    continue;
                }
                
                const values = linesA[i].split('\t');
                
                if (i < 6 || values[0] === 'çé‡‘' || values[0] === 'Rows per page:' || values[0] === '' || values[0].match(/^\d+â€“\d+ of \d+$/)) {
                    continue;
                }
                
                if (values.length >= 5 && !isNaN(values[3])) {
                    const nextLineValues = i + 1 < linesA.length ? linesA[i + 1].split('\t') : [];
                    const method = nextLineValues[0] || '';
                    
                    if (method === 'O' || method === 'D') {
                        dataA.push({
                            productType: values[0],
                            product: values[1],
                            value1: parseInt(values[2]),
                            value2: parseFloat(values[3]),
                            unit: values[4],
                            method: method
                        });
                        skipNext = true;
                    }
                }
            }
            
            // å…ˆåŸ·è¡Œå¢é‡è¦å‰‡æª¢æŸ¥ï¼ˆåªæª¢æŸ¥æœ‰è¦å‰‡çš„ç”¢å“ï¼‰
            const stepCheckResults = [];
            dataA.forEach(rowA => {
                const stepCheck = checkStepRule(rowA.product, rowA.value2);
                if (stepCheck) {
                    stepCheckResults.push({
                        productType: rowA.productType,
                        product: rowA.product,
                        value: rowA.value2,
                        unit: rowA.unit,
                        step: stepCheck.step,
                        valid: stepCheck.valid,
                        reason: stepCheck.reason
                    });
                }
            });
            
            // å¦‚æœæœ‰éœ€è¦æª¢æŸ¥çš„ç”¢å“ï¼Œé¡¯ç¤ºå¢é‡æª¢æŸ¥çµæœ
            if (stepCheckResults.length > 0) {
                stepHTML += '<div class="step-check"><h3>ğŸ”§ å¢é‡è¦å‰‡æª¢æŸ¥ï¼ˆåƒ…é¡¯ç¤ºéœ€æª¢æŸ¥çš„ç”¢å“ï¼‰ï¼š</h3>';
                stepHTML += '<table><tr><th>ç”¢å“é¡å‹</th><th>ç”¢å“</th><th>æ•¸å€¼</th><th>å–®ä½</th><th>å¢é‡è¦æ±‚</th><th>æª¢æŸ¥çµæœ</th><th>èªªæ˜</th></tr>';
                
                stepCheckResults.forEach(result => {
                    const rowClass = result.valid ? 'step-pass' : 'step-fail';
                    
                    stepHTML += `<tr class="${rowClass}">
                        <td>${result.productType}</td>
                        <td>${result.product}</td>
                        <td>${result.value}</td>
                        <td>${result.unit}</td>
                        <td>${result.step}çš„å€æ•¸</td>
                        <td><strong>${result.valid ? 'âœ… é€šé' : 'âŒ ä¸é€šé'}</strong></td>
                        <td>${result.reason}</td>
                    </tr>`;
                });
                
                stepHTML += '</table></div>';
            } else {
                stepHTML = '<div class="step-check"><h3>ğŸ”§ å¢é‡è¦å‰‡æª¢æŸ¥ï¼š</h3><p>ç„¡éœ€é€²è¡Œå¢é‡è¦å‰‡æª¢æŸ¥çš„ç”¢å“</p></div>';
            }
            
            document.getElementById('stepCheckResult').innerHTML = stepHTML;
            
            // è§£æRBOç¶²é æ•¸æ“š
            const linesB = tableB.trim().split('\n');
            const dataB = [];
            skipNext = false;

            for (let i = 0; i < linesB.length; i++) {
                if (skipNext) {
                    skipNext = false;
                    continue;
                }
                
                const values = linesB[i].split('\t');
                
                if (i < 2) continue;
                
                if (i === 2) continue; // è·³éè¡¨é ­
                
                if (values.length >= 3 && values[1] && (values[1].includes('Trade Comm') || values[1].includes('Trade Volume'))) {
                    if (values.length >= 8 && values[7]) {
                        dataB.push({
                            rebateType: values[1],
                            selection: values[2],
                            minLot: parseFloat(values[3]),
                            startDate: values[4],
                            endDate: values[5],
                            unit: values[6],
                            amount: parseFloat(values[7]),
                            method: values[8]
                        });
                    } else {
                        if (i + 1 < linesB.length) {
                            const nextValues = linesB[i + 1].split('\t');
                            if (nextValues.length >= 3) {
                                dataB.push({
                                    rebateType: values[1],
                                    selection: values[2],
                                    minLot: parseFloat(values[3]),
                                    startDate: values[4],
                                    endDate: values[5] || '',
                                    unit: nextValues[0],
                                    amount: parseFloat(nextValues[1]),
                                    method: nextValues[2]
                                });
                                skipNext = true;
                            }
                        }
                    }
                }
            }

            // åŸ·è¡Œæ ¸å°
            resultHTML += '<div class="debug-info"><h3>ğŸ“Š æœ€çµ‚æ ¸å°çµæœï¼š</h3>';
            resultHTML += '<table class="result-table"><tr><th>ç”¢å“é¡å‹</th><th>ç”¢å“</th><th>Aæ‰‹æ•¸</th><th>Aæ•¸å€¼</th><th>B Selection</th><th>B Min. Lot</th><th>Bæ•¸å€¼</th><th>Bé–‹å§‹æ—¥æœŸ</th><th>BçµæŸæ—¥æœŸ</th><th>Aæ–¹æ³•</th><th>Bæ–¹æ³•</th><th>ç‹€æ…‹</th></tr>';
            
            dataA.forEach(rowA => {
                const mappedProducts = getMappedProduct(rowA.productType, rowA.product);
                
                let status = '';
                let valueB = 'N/A';
                let bSelection = 'N/A';
                let bMinLot = 'N/A';
                let bStartDate = 'N/A';
                let bEndDate = 'N/A';
                let bMethod = 'N/A';
                let rowClass = 'not-found';
                
                console.log('Checking product:', rowA.product, 'Mapped to:', mappedProducts);
                
                // æ‰¾å‡ºæ‰€æœ‰åŒ¹é…çš„è®°å½•
                const allMatches = [];
                mappedProducts.forEach(product => {
                    dataB.forEach(rowB => {
                        if (rowB.selection === product) {
                            allMatches.push(rowB);
                        }
                    });
                });
                
                console.log('Found matches:', allMatches);
                
                // ä¼˜å…ˆé€‰æ‹©Min. Lotä¸º0çš„æœ‰æ•ˆè®°å½•
                const zeroLotMatches = allMatches.filter(rowB => 
                    rowB.minLot === 0 && 
                    isDateValid(rowB.startDate, rowB.endDate)
                );
                
                if (allMatches.length === 0) {
                    status = 'âŒ RBOä¸­æ²’æœ‰è©²ç”¢å“';
                    rowClass = 'not-found';
                } else if (zeroLotMatches.length === 0) {
                    status = 'âŒ RBOä¸­æ²’æœ‰è©²ç”¢å“(ç„¡0æ‰‹æ•¸è¨˜éŒ„)';
                    rowClass = 'not-found';
                } else {
                    const selectedMatch = zeroLotMatches[0];
                    valueB = selectedMatch.amount;
                    bSelection = selectedMatch.selection;
                    bMinLot = selectedMatch.minLot;
                    bStartDate = selectedMatch.startDate || 'ç„¡é™æœŸ';
                    bEndDate = selectedMatch.endDate || 'ç„¡é™æœŸ';
                    bMethod = selectedMatch.method;
                    
                    if (!isMethodMatch(rowA.method, selectedMatch.method)) {
                        status = 'âš ï¸ ç”¢å“å­˜åœ¨ä½†æ–¹æ³•ä¸åŒ¹é…';
                        rowClass = 'method-mismatch';
                    } else if (rowA.unit === '%' && rowA.value2 <= valueB) {
                        status = 'âœ… é€šé';
                        rowClass = 'pass';
                    } else if (rowA.unit !== '%' && rowA.value2 <= valueB) {
                        status = 'âœ… é€šé';
                        rowClass = 'pass';
                    } else {
                        status = 'âŒ ä¸é€šé';
                        rowClass = 'fail';
                    }
                }
                
                resultHTML += `<tr class="${rowClass}">
                    <td>${rowA.productType}</td>
                    <td>${rowA.product}</td>
                    <td>${rowA.value1}</td>
                    <td>${rowA.value2}</td>
                    <td>${bSelection}</td>
                    <td>${bMinLot}</td>
                    <td>${valueB}</td>
                    <td>${bStartDate}</td>
                    <td>${bEndDate}</td>
                    <td>${getMethodName(rowA.method)}</td>
                    <td>${bMethod}</td>
                    <td><strong>${status}</strong></td>
                </tr>`;
            });
            
            resultHTML += '</table></div>';
            document.getElementById('finalResult').innerHTML = resultHTML;

            // é¡¯ç¤ºè§£æå¾Œçš„æ•¸æ“š
            debugHTML = '<div class="debug-info"><h3>è§£æå¾Œçš„Aæ•¸æ“šï¼š</h3><table><tr><th>ç”¢å“é¡å‹</th><th>ç”¢å“</th><th>æ‰‹æ•¸</th><th>æ•¸å€¼</th><th>å–®ä½</th><th>æ–¹æ³•</th></tr>';
            dataA.forEach(row => {
                debugHTML += `<tr><td>${row.productType}</td><td>${row.product}</td><td>${row.value1}</td><td>${row.value2}</td><td>${row.unit}</td><td>${getMethodName(row.method)}</td></tr>`;
            });
            debugHTML += '</table></div>';

            debugHTML += '<div class="debug-info"><h3>è§£æå¾Œçš„Bæ•¸æ“šï¼š</h3><table><tr><th>Rebate Type</th><th>Selection</th><th>Min. Lot</th><th>Start Date</th><th>End Date</th><th>Unit</th><th>Amount</th><th>Method</th></tr>';
            dataB.forEach(row => {
                debugHTML += `<tr>
                    <td>${row.rebateType}</td>
                    <td>${row.selection}</td>
                    <td>${row.minLot}</td>
                    <td>${row.startDate || 'ç„¡é™æœŸ'}</td>
                    <td>${row.endDate || 'ç„¡é™æœŸ'}</td>
                    <td>${row.unit}</td>
                    <td>${row.amount}</td>
                    <td>${row.method}</td>
                </tr>`;
            });
            debugHTML += '</table></div>';

            document.getElementById('debugResult').innerHTML = debugHTML;
        }
        
        function clearAll() {
            document.getElementById('tableA').value = '';
            document.getElementById('tableB').value = '';
            document.getElementById('stepCheckResult').innerHTML = '';
            document.getElementById('debugResult').innerHTML = '';
            document.getElementById('finalResult').innerHTML = '';
        }
        
        // è‡ªå‹•åŸ·è¡Œè§£æ
        setTimeout(() => {
            parseAndCheck();
        }, 1000);
    </script>
</body>
</html>
